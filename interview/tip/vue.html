<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue面试题 | H.Z的学习笔记</title>
    <meta name="description" content="HZ的前端学习笔记，">
    <script src="//pingjs.qq.com/h5/stats.js?v2.0.4" name="MTAH5" sid="500699019" cid="500699020"></script>
  <meta data-n-head="true" data-hid="keywords" name="keywords" content="HZ的前端学习笔记，其中包含HTML, JavaScript, css, Vue, React Nodejs, flutter等">
  <meta data-n-head="true" data-hid="description" name="description" content="HZ的前端学习笔记，其中包含HTML, JavaScript, css, Vue, React Nodejs, flutter等">
    <meta bgImage="http://study.closeeyes.cn/js2.jpg">
    <link rel="preload" href="/assets/css/0.styles.16a3a553.css" as="style"><link rel="preload" href="/assets/js/app.c78b02b4.js" as="script"><link rel="preload" href="/assets/js/2.72b22dfe.js" as="script"><link rel="preload" href="/assets/js/47.067af22f.js" as="script"><link rel="preload" href="/assets/js/10.5d4adb2e.js" as="script"><link rel="prefetch" href="/assets/js/11.4ef768d0.js"><link rel="prefetch" href="/assets/js/12.ca276384.js"><link rel="prefetch" href="/assets/js/13.33574ce2.js"><link rel="prefetch" href="/assets/js/14.f8656307.js"><link rel="prefetch" href="/assets/js/15.fe0c999e.js"><link rel="prefetch" href="/assets/js/16.9b1d4ea9.js"><link rel="prefetch" href="/assets/js/17.7a7ef99f.js"><link rel="prefetch" href="/assets/js/18.22f32aae.js"><link rel="prefetch" href="/assets/js/19.b32e4dae.js"><link rel="prefetch" href="/assets/js/20.33b6bdc2.js"><link rel="prefetch" href="/assets/js/21.c43113db.js"><link rel="prefetch" href="/assets/js/22.298d5d5f.js"><link rel="prefetch" href="/assets/js/23.016c3c54.js"><link rel="prefetch" href="/assets/js/24.2d7d1aed.js"><link rel="prefetch" href="/assets/js/25.7be72dee.js"><link rel="prefetch" href="/assets/js/26.9e4abae2.js"><link rel="prefetch" href="/assets/js/27.386a36b5.js"><link rel="prefetch" href="/assets/js/28.dbf4f39a.js"><link rel="prefetch" href="/assets/js/29.2031c54c.js"><link rel="prefetch" href="/assets/js/3.0b664d57.js"><link rel="prefetch" href="/assets/js/30.40f1dbed.js"><link rel="prefetch" href="/assets/js/31.152fac60.js"><link rel="prefetch" href="/assets/js/32.e22059e3.js"><link rel="prefetch" href="/assets/js/33.0001da11.js"><link rel="prefetch" href="/assets/js/34.8d35058b.js"><link rel="prefetch" href="/assets/js/35.9b3de046.js"><link rel="prefetch" href="/assets/js/36.1d7566d2.js"><link rel="prefetch" href="/assets/js/37.7b3a5b14.js"><link rel="prefetch" href="/assets/js/38.e8c56698.js"><link rel="prefetch" href="/assets/js/39.5c596f42.js"><link rel="prefetch" href="/assets/js/4.8c92dc1f.js"><link rel="prefetch" href="/assets/js/40.b1ab5679.js"><link rel="prefetch" href="/assets/js/41.6202c7a3.js"><link rel="prefetch" href="/assets/js/42.04f6a3f8.js"><link rel="prefetch" href="/assets/js/43.393f7675.js"><link rel="prefetch" href="/assets/js/44.bf712c45.js"><link rel="prefetch" href="/assets/js/45.a70f4bdb.js"><link rel="prefetch" href="/assets/js/46.f9cdb924.js"><link rel="prefetch" href="/assets/js/48.6069c083.js"><link rel="prefetch" href="/assets/js/49.4e6072fb.js"><link rel="prefetch" href="/assets/js/5.0329192f.js"><link rel="prefetch" href="/assets/js/50.a3d5e589.js"><link rel="prefetch" href="/assets/js/51.7575b366.js"><link rel="prefetch" href="/assets/js/6.4d536703.js"><link rel="prefetch" href="/assets/js/7.681f216d.js"><link rel="prefetch" href="/assets/js/8.10815b8c.js"><link rel="prefetch" href="/assets/js/9.3b8a74fe.js">
    <link rel="stylesheet" href="/assets/css/0.styles.16a3a553.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="layout" data-v-7ee5536a><header class="header clearfix" data-v-5b6d54b8 data-v-7ee5536a><div class="content-logo" data-v-5b6d54b8><div class="title" data-v-5b6d54b8>H.Z的学习笔记</div></div> <div class="nav-wrapper" data-v-5b6d54b8><nav class="navs" data-v-5b6d54b8></nav></div></header> <div class="search-box" style="margin:20px 0;" data-v-4b9f78e4 data-v-7ee5536a><input aria-label="Search" autocomplete="off" spellcheck="false" placeholder="请输入搜索关键词~" value="" data-v-4b9f78e4> <!----></div> <main data-v-7ee5536a><div class="page" data-v-4378bf22 data-v-7ee5536a><h2 style="border-bottom: none; margin-bottom: 0;display:flex;" data-v-4378bf22><p style="padding: 0; margin:0; flex:4" data-v-4378bf22>vue面试题</p> <div style="flex:1;" data-v-4378bf22><ul data-v-4378bf22><li class="tag" style="background:;color:#fff;" data-v-4378bf22><i style="border-right-color:;" data-v-4378bf22></i> <span data-v-4378bf22>vue</span></li></ul></div></h2> <div class="content__default" data-v-4378bf22><h2 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h2> <h2 id="_1-如何理解mvvm原理"><a href="#_1-如何理解mvvm原理" aria-hidden="true" class="header-anchor">#</a> 1. 如何理解MVVM原理</h2> <blockquote><p>MVVM是<code>Model-View-ViewModel</code>缩写，也就是把<code>MVC</code>中的<code>Controller</code>演变成<code>ViewModel</code>。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据</p></blockquote> <h2 id="_2-响应式数据的原理是什么"><a href="#_2-响应式数据的原理是什么" aria-hidden="true" class="header-anchor">#</a> 2. 响应式数据的原理是什么</h2> <ul><li><p>Vue在初始化数据的时候，会使用<code>Object.defineProperty</code>重新定义data中所有属性（也就是数据劫持），当页面中对应的属性</p> <p>1、把一个普通的js对象传给Vue实例的data选项对象</p> <p>2、Vue将遍历此对象的所有的属性，并使用Object.defineProperty把这些属性全部转换为getter/setter</p> <p>3、Vue内部会对数据进行劫持操作，进而追踪依赖，在属性被访问和修改时通知变化</p></li></ul> <h2 id="_3-vue中如何检测数组的变化的"><a href="#_3-vue中如何检测数组的变化的" aria-hidden="true" class="header-anchor">#</a> 3. Vue中如何检测数组的变化的</h2> <h2 id="_4-为何vue采用异步渲染"><a href="#_4-为何vue采用异步渲染" aria-hidden="true" class="header-anchor">#</a> 4. 为何Vue采用异步渲染</h2> <blockquote><p>节约性能</p></blockquote> <h2 id="_5-nexttick实现原理"><a href="#_5-nexttick实现原理" aria-hidden="true" class="header-anchor">#</a> 5. $nextTick实现原理</h2> <h2 id="_6-vue父子组件的生命周期调用顺序"><a href="#_6-vue父子组件的生命周期调用顺序" aria-hidden="true" class="header-anchor">#</a> 6. Vue父子组件的生命周期调用顺序</h2> <h2 id="_7-vue中的computed的特点"><a href="#_7-vue中的computed的特点" aria-hidden="true" class="header-anchor">#</a> 7. Vue中的Computed的特点</h2> <ul><li><p><code>Computed</code>本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。</p></li> <li><p><code>Watch</code>没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开<code>deep：true</code>选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用<code>字符串形式</code>监听，如果没有写到组件中，不要忘记使用<code>unWatch手动注销</code>哦。</p></li></ul> <h2 id="_8-watch中的-deep-true如何实现"><a href="#_8-watch中的-deep-true如何实现" aria-hidden="true" class="header-anchor">#</a> 8. Watch中的 deep: true如何实现</h2> <h2 id="_9-vue中事件绑定的原理"><a href="#_9-vue中事件绑定的原理" aria-hidden="true" class="header-anchor">#</a> 9. Vue中事件绑定的原理</h2> <ul><li>原生dom事件的绑定，采用的是addEventListener实现</li> <li>组件绑定事件采用的是$on方法</li></ul> <h2 id="_10-vue中的v-html存在什么问题"><a href="#_10-vue中的v-html存在什么问题" aria-hidden="true" class="header-anchor">#</a> 10. Vue中的v-html存在什么问题</h2> <h2 id="_11-v-if和v-show的区别"><a href="#_11-v-if和v-show的区别" aria-hidden="true" class="header-anchor">#</a> 11. v-if和v-show的区别</h2> <h2 id="_12-v-model的实现原理"><a href="#_12-v-model的实现原理" aria-hidden="true" class="header-anchor">#</a> 12. v-model的实现原理</h2> <h2 id="_13-组件中的data为什么是一个函数"><a href="#_13-组件中的data为什么是一个函数" aria-hidden="true" class="header-anchor">#</a> 13. 组件中的data为什么是一个函数</h2> <h2 id="_14-vue中组件之间的通信"><a href="#_14-vue中组件之间的通信" aria-hidden="true" class="header-anchor">#</a> 14. Vue中组件之间的通信</h2> <h2 id="_15-作用域插槽"><a href="#_15-作用域插槽" aria-hidden="true" class="header-anchor">#</a> 15. 作用域插槽</h2> <h2 id="_16-diff算法的时间复杂度"><a href="#_16-diff算法的时间复杂度" aria-hidden="true" class="header-anchor">#</a> 16. diff算法的时间复杂度</h2> <h2 id="_17-简述diff算法的原理"><a href="#_17-简述diff算法的原理" aria-hidden="true" class="header-anchor">#</a> 17. 简述diff算法的原理</h2> <h2 id="_18-v-for中为什么要使用key"><a href="#_18-v-for中为什么要使用key" aria-hidden="true" class="header-anchor">#</a> 18. v-for中为什么要使用key</h2> <h2 id="_19-vue模板编译原理"><a href="#_19-vue模板编译原理" aria-hidden="true" class="header-anchor">#</a> 19. Vue模板编译原理</h2> <p>简单说，Vue的编译过程就是将<code>template</code>转化为<code>render</code>函数的过程。会经历以下阶段：</p> <ul><li>生成AST树</li> <li>优化</li> <li>codegen</li></ul> <p>首先解析模版，生成<code>AST语法树</code>(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p> <p>Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以<code>跳过对它们的比对</code>，对运行时的模板起到很大的优化作用。</p> <p>编译的最后一步是<code>将优化后的AST树转换为可执行的代码</code>。</p> <h2 id="_20-vue中常见的性能优化"><a href="#_20-vue中常见的性能优化" aria-hidden="true" class="header-anchor">#</a> 20. Vue中常见的性能优化</h2> <h3 id="编码阶段"><a href="#编码阶段" aria-hidden="true" class="header-anchor">#</a> 编码阶段</h3> <ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li> <li>v-if和v-for不能连用</li> <li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li> <li>SPA 页面采用keep-alive缓存组件</li> <li>在更多的情况下，使用v-if替代v-show</li> <li>key保证唯一</li> <li>使用路由懒加载、异步组件</li> <li>防抖、节流</li> <li>第三方模块按需导入</li> <li>长列表滚动到可视区域动态加载</li> <li>图片懒加载</li></ul> <h3 id="seo优化"><a href="#seo优化" aria-hidden="true" class="header-anchor">#</a> SEO优化</h3> <ul><li>预渲染</li> <li>服务端渲染SSR</li></ul> <h3 id="打包优化"><a href="#打包优化" aria-hidden="true" class="header-anchor">#</a> 打包优化</h3> <ul><li>压缩代码</li> <li>Tree Shaking/Scope Hoisting</li> <li>使用cdn加载第三方模块</li> <li>多线程打包happypack</li> <li>splitChunks抽离公共文件</li> <li>sourceMap优化</li></ul> <h3 id="用户体验"><a href="#用户体验" aria-hidden="true" class="header-anchor">#</a> 用户体验</h3> <ul><li>骨架屏</li> <li>PWA</li></ul> <p>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</p> <h2 id="_21-为什么要使用异步组件"><a href="#_21-为什么要使用异步组件" aria-hidden="true" class="header-anchor">#</a> 21. 为什么要使用异步组件</h2> <h2 id="_22-keep-alive组件的了解"><a href="#_22-keep-alive组件的了解" aria-hidden="true" class="header-anchor">#</a> 22. keep-alive组件的了解</h2> <p><code>keep-alive</code>可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p> <p>常用的两个属性<code>include/exclude</code>，允许组件有条件的进行缓存。</p> <p>两个生命周期<code>activated/deactivated</code>，用来得知当前组件是否处于活跃状态。</p> <p>keep-alive的中还运用了<code>LRU(Least Recently Used)</code>算法。</p> <h2 id="_23-hash和history路由的原理"><a href="#_23-hash和history路由的原理" aria-hidden="true" class="header-anchor">#</a> 23. hash和history路由的原理</h2> <p><code>location.hash</code>的值实际就是URL中<code>#</code>后面的东西。</p> <p>history实际采用了HTML5中提供的API来实现，主要有<code>history.pushState()</code>和<code>history.replaceState()</code>。</p> <h2 id="_24-vue-router导航守卫"><a href="#_24-vue-router导航守卫" aria-hidden="true" class="header-anchor">#</a> 24. Vue-Router导航守卫</h2> <h2 id="_25-vuex中action和mutation的区别"><a href="#_25-vuex中action和mutation的区别" aria-hidden="true" class="header-anchor">#</a> 25. vuex中action和mutation的区别</h2> <h2 id="_26-简述vuex的工作原理"><a href="#_26-简述vuex的工作原理" aria-hidden="true" class="header-anchor">#</a> 26. 简述Vuex的工作原理</h2> <h2 id="_27-vue3-0有哪些改进"><a href="#_27-vue3-0有哪些改进" aria-hidden="true" class="header-anchor">#</a> 27. Vue3.0有哪些改进</h2> <h2 id="_28-react和vue的区别"><a href="#_28-react和vue的区别" aria-hidden="true" class="header-anchor">#</a> 28. react和vue的区别</h2> <ol><li>监听数据变化的方式</li></ol> <pre><code>- vue是用数据劫持
- react setState
</code></pre> <ol start="2"><li>数据流</li></ol> <pre><code>- vue 父子之间使用 props $emit, dom之间使用v-model
- react props state
</code></pre> <ol start="3"><li>组件通信</li> <li>模板渲染方式</li></ol> <pre><code>- vue template 指令的方式
- jsx
</code></pre> <ol start="5"><li>渲染过程</li></ol> <pre><code>- 渲染过程中vue会跟踪每个组件的依赖关系，不需要重新渲染整个组件树
- react diff 需要使用 shouldComponentUpdate生命周期控制
</code></pre> <div class="gitalk-container"><div id="gitalk-container"></div></div></div></div></main> <footer class="footer" data-v-46dae662 data-v-7ee5536a>
  
  <div style="margin-top:10px;" data-v-46dae662><a target="_block" href="http://www.beian.miit.gov.cn/" class="footer-a" data-v-46dae662>浙ICP备18051710号</a></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c78b02b4.js" defer></script><script src="/assets/js/2.72b22dfe.js" defer></script><script src="/assets/js/47.067af22f.js" defer></script><script src="/assets/js/10.5d4adb2e.js" defer></script>
  </body>
</html>
