(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{80:function(e,a,t){"use strict";t.r(a);var v=t(0),_=Object(v.a)({},function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),t("h2",{attrs:{id:"_1-如何理解mvvm原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-如何理解mvvm原理","aria-hidden":"true"}},[e._v("#")]),e._v(" 1. 如何理解MVVM原理")]),e._v(" "),t("blockquote",[t("p",[e._v("MVVM是"),t("code",[e._v("Model-View-ViewModel")]),e._v("缩写，也就是把"),t("code",[e._v("MVC")]),e._v("中的"),t("code",[e._v("Controller")]),e._v("演变成"),t("code",[e._v("ViewModel")]),e._v("。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据")])]),e._v(" "),t("h2",{attrs:{id:"_2-响应式数据的原理是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-响应式数据的原理是什么","aria-hidden":"true"}},[e._v("#")]),e._v(" 2. 响应式数据的原理是什么")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Vue在初始化数据的时候，会使用"),t("code",[e._v("Object.defineProperty")]),e._v("重新定义data中所有属性（也就是数据劫持），当页面中对应的属性")]),e._v(" "),t("p",[e._v("1、把一个普通的js对象传给Vue实例的data选项对象")]),e._v(" "),t("p",[e._v("2、Vue将遍历此对象的所有的属性，并使用Object.defineProperty把这些属性全部转换为getter/setter")]),e._v(" "),t("p",[e._v("3、Vue内部会对数据进行劫持操作，进而追踪依赖，在属性被访问和修改时通知变化")])])]),e._v(" "),t("h2",{attrs:{id:"_3-vue中如何检测数组的变化的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue中如何检测数组的变化的","aria-hidden":"true"}},[e._v("#")]),e._v(" 3. Vue中如何检测数组的变化的")]),e._v(" "),t("h2",{attrs:{id:"_4-为何vue采用异步渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-为何vue采用异步渲染","aria-hidden":"true"}},[e._v("#")]),e._v(" 4. 为何Vue采用异步渲染")]),e._v(" "),t("blockquote",[t("p",[e._v("节约性能")])]),e._v(" "),t("h2",{attrs:{id:"_5-nexttick实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-nexttick实现原理","aria-hidden":"true"}},[e._v("#")]),e._v(" 5. $nextTick实现原理")]),e._v(" "),t("h2",{attrs:{id:"_6-vue父子组件的生命周期调用顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue父子组件的生命周期调用顺序","aria-hidden":"true"}},[e._v("#")]),e._v(" 6. Vue父子组件的生命周期调用顺序")]),e._v(" "),t("h2",{attrs:{id:"_7-vue中的computed的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue中的computed的特点","aria-hidden":"true"}},[e._v("#")]),e._v(" 7. Vue中的Computed的特点")]),e._v(" "),t("ul",[t("li",[t("p",[t("code",[e._v("Computed")]),e._v("本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("Watch")]),e._v("没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开"),t("code",[e._v("deep：true")]),e._v("选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用"),t("code",[e._v("字符串形式")]),e._v("监听，如果没有写到组件中，不要忘记使用"),t("code",[e._v("unWatch手动注销")]),e._v("哦。")])])]),e._v(" "),t("h2",{attrs:{id:"_8-watch中的-deep-true如何实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-watch中的-deep-true如何实现","aria-hidden":"true"}},[e._v("#")]),e._v(" 8. Watch中的 deep: true如何实现")]),e._v(" "),t("h2",{attrs:{id:"_9-vue中事件绑定的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-vue中事件绑定的原理","aria-hidden":"true"}},[e._v("#")]),e._v(" 9. Vue中事件绑定的原理")]),e._v(" "),t("ul",[t("li",[e._v("原生dom事件的绑定，采用的是addEventListener实现")]),e._v(" "),t("li",[e._v("组件绑定事件采用的是$on方法")])]),e._v(" "),t("h2",{attrs:{id:"_10-vue中的v-html存在什么问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue中的v-html存在什么问题","aria-hidden":"true"}},[e._v("#")]),e._v(" 10. Vue中的v-html存在什么问题")]),e._v(" "),t("h2",{attrs:{id:"_11-v-if和v-show的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-v-if和v-show的区别","aria-hidden":"true"}},[e._v("#")]),e._v(" 11. v-if和v-show的区别")]),e._v(" "),t("h2",{attrs:{id:"_12-v-model的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-v-model的实现原理","aria-hidden":"true"}},[e._v("#")]),e._v(" 12. v-model的实现原理")]),e._v(" "),t("h2",{attrs:{id:"_13-组件中的data为什么是一个函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-组件中的data为什么是一个函数","aria-hidden":"true"}},[e._v("#")]),e._v(" 13. 组件中的data为什么是一个函数")]),e._v(" "),t("h2",{attrs:{id:"_14-vue中组件之间的通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-vue中组件之间的通信","aria-hidden":"true"}},[e._v("#")]),e._v(" 14. Vue中组件之间的通信")]),e._v(" "),t("h2",{attrs:{id:"_15-作用域插槽"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15-作用域插槽","aria-hidden":"true"}},[e._v("#")]),e._v(" 15. 作用域插槽")]),e._v(" "),t("h2",{attrs:{id:"_16-diff算法的时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-diff算法的时间复杂度","aria-hidden":"true"}},[e._v("#")]),e._v(" 16. diff算法的时间复杂度")]),e._v(" "),t("h2",{attrs:{id:"_17-简述diff算法的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-简述diff算法的原理","aria-hidden":"true"}},[e._v("#")]),e._v(" 17. 简述diff算法的原理")]),e._v(" "),t("h2",{attrs:{id:"_18-v-for中为什么要使用key"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_18-v-for中为什么要使用key","aria-hidden":"true"}},[e._v("#")]),e._v(" 18. v-for中为什么要使用key")]),e._v(" "),t("h2",{attrs:{id:"_19-vue模板编译原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_19-vue模板编译原理","aria-hidden":"true"}},[e._v("#")]),e._v(" 19. Vue模板编译原理")]),e._v(" "),t("p",[e._v("简单说，Vue的编译过程就是将"),t("code",[e._v("template")]),e._v("转化为"),t("code",[e._v("render")]),e._v("函数的过程。会经历以下阶段：")]),e._v(" "),t("ul",[t("li",[e._v("生成AST树")]),e._v(" "),t("li",[e._v("优化")]),e._v(" "),t("li",[e._v("codegen")])]),e._v(" "),t("p",[e._v("首先解析模版，生成"),t("code",[e._v("AST语法树")]),e._v("(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。")]),e._v(" "),t("p",[e._v("Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以"),t("code",[e._v("跳过对它们的比对")]),e._v("，对运行时的模板起到很大的优化作用。")]),e._v(" "),t("p",[e._v("编译的最后一步是"),t("code",[e._v("将优化后的AST树转换为可执行的代码")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"_20-vue中常见的性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_20-vue中常见的性能优化","aria-hidden":"true"}},[e._v("#")]),e._v(" 20. Vue中常见的性能优化")]),e._v(" "),t("h3",{attrs:{id:"编码阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编码阶段","aria-hidden":"true"}},[e._v("#")]),e._v(" 编码阶段")]),e._v(" "),t("ul",[t("li",[e._v("尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher")]),e._v(" "),t("li",[e._v("v-if和v-for不能连用")]),e._v(" "),t("li",[e._v("如果需要使用v-for给每项元素绑定事件时使用事件代理")]),e._v(" "),t("li",[e._v("SPA 页面采用keep-alive缓存组件")]),e._v(" "),t("li",[e._v("在更多的情况下，使用v-if替代v-show")]),e._v(" "),t("li",[e._v("key保证唯一")]),e._v(" "),t("li",[e._v("使用路由懒加载、异步组件")]),e._v(" "),t("li",[e._v("防抖、节流")]),e._v(" "),t("li",[e._v("第三方模块按需导入")]),e._v(" "),t("li",[e._v("长列表滚动到可视区域动态加载")]),e._v(" "),t("li",[e._v("图片懒加载")])]),e._v(" "),t("h3",{attrs:{id:"seo优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#seo优化","aria-hidden":"true"}},[e._v("#")]),e._v(" SEO优化")]),e._v(" "),t("ul",[t("li",[e._v("预渲染")]),e._v(" "),t("li",[e._v("服务端渲染SSR")])]),e._v(" "),t("h3",{attrs:{id:"打包优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打包优化","aria-hidden":"true"}},[e._v("#")]),e._v(" 打包优化")]),e._v(" "),t("ul",[t("li",[e._v("压缩代码")]),e._v(" "),t("li",[e._v("Tree Shaking/Scope Hoisting")]),e._v(" "),t("li",[e._v("使用cdn加载第三方模块")]),e._v(" "),t("li",[e._v("多线程打包happypack")]),e._v(" "),t("li",[e._v("splitChunks抽离公共文件")]),e._v(" "),t("li",[e._v("sourceMap优化")])]),e._v(" "),t("h3",{attrs:{id:"用户体验"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用户体验","aria-hidden":"true"}},[e._v("#")]),e._v(" 用户体验")]),e._v(" "),t("ul",[t("li",[e._v("骨架屏")]),e._v(" "),t("li",[e._v("PWA")])]),e._v(" "),t("p",[e._v("还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。")]),e._v(" "),t("h2",{attrs:{id:"_21-为什么要使用异步组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_21-为什么要使用异步组件","aria-hidden":"true"}},[e._v("#")]),e._v(" 21. 为什么要使用异步组件")]),e._v(" "),t("h2",{attrs:{id:"_22-keep-alive组件的了解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_22-keep-alive组件的了解","aria-hidden":"true"}},[e._v("#")]),e._v(" 22. keep-alive组件的了解")]),e._v(" "),t("p",[t("code",[e._v("keep-alive")]),e._v("可以实现组件缓存，当组件切换时不会对当前组件进行卸载。")]),e._v(" "),t("p",[e._v("常用的两个属性"),t("code",[e._v("include/exclude")]),e._v("，允许组件有条件的进行缓存。")]),e._v(" "),t("p",[e._v("两个生命周期"),t("code",[e._v("activated/deactivated")]),e._v("，用来得知当前组件是否处于活跃状态。")]),e._v(" "),t("p",[e._v("keep-alive的中还运用了"),t("code",[e._v("LRU(Least Recently Used)")]),e._v("算法。")]),e._v(" "),t("h2",{attrs:{id:"_23-hash和history路由的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_23-hash和history路由的原理","aria-hidden":"true"}},[e._v("#")]),e._v(" 23. hash和history路由的原理")]),e._v(" "),t("p",[t("code",[e._v("location.hash")]),e._v("的值实际就是URL中"),t("code",[e._v("#")]),e._v("后面的东西。")]),e._v(" "),t("p",[e._v("history实际采用了HTML5中提供的API来实现，主要有"),t("code",[e._v("history.pushState()")]),e._v("和"),t("code",[e._v("history.replaceState()")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"_24-vue-router导航守卫"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_24-vue-router导航守卫","aria-hidden":"true"}},[e._v("#")]),e._v(" 24. Vue-Router导航守卫")]),e._v(" "),t("h2",{attrs:{id:"_25-vuex中action和mutation的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_25-vuex中action和mutation的区别","aria-hidden":"true"}},[e._v("#")]),e._v(" 25. vuex中action和mutation的区别")]),e._v(" "),t("h2",{attrs:{id:"_26-简述vuex的工作原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_26-简述vuex的工作原理","aria-hidden":"true"}},[e._v("#")]),e._v(" 26. 简述Vuex的工作原理")]),e._v(" "),t("h2",{attrs:{id:"_27-vue3-0有哪些改进"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_27-vue3-0有哪些改进","aria-hidden":"true"}},[e._v("#")]),e._v(" 27. Vue3.0有哪些改进")]),e._v(" "),t("h2",{attrs:{id:"_28-react和vue的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_28-react和vue的区别","aria-hidden":"true"}},[e._v("#")]),e._v(" 28. react和vue的区别")]),e._v(" "),t("ol",[t("li",[e._v("监听数据变化的方式")])]),e._v(" "),t("pre",[t("code",[e._v("- vue是用数据劫持\n- react setState\n")])]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("数据流")])]),e._v(" "),t("pre",[t("code",[e._v("- vue 父子之间使用 props $emit, dom之间使用v-model\n- react props state\n")])]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("组件通信")]),e._v(" "),t("li",[e._v("模板渲染方式")])]),e._v(" "),t("pre",[t("code",[e._v("- vue template 指令的方式\n- jsx\n")])]),e._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[e._v("渲染过程")])]),e._v(" "),t("pre",[t("code",[e._v("- 渲染过程中vue会跟踪每个组件的依赖关系，不需要重新渲染整个组件树\n- react diff 需要使用 shouldComponentUpdate生命周期控制\n")])]),e._v(" "),t("CommentZHU")],1)},[],!1,null,null,null);a.default=_.exports}}]);